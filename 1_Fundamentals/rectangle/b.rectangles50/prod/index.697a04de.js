"undefined"!=typeof Float32Array&&Float32Array,Math.random;Math.PI;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});function t(t,e,r){const o=t.createShader(e);t.shaderSource(o,r),t.compileShader(o);if(t.getShaderParameter(o,t.COMPILE_STATUS))return o;{const e=t.getShaderInfoLog(o);throw t.deleteShader(o),new Error(`HelperFunctions-createShader-Error: ${e}`)}}class e{constructor(t,e,r,o){this.gl=t,this.buffer_type="ARRAY",this.data_type=e,this.attributeLocation=this.gl.getAttribLocation(r,o),this.arrayBuffer=this.gl.createBuffer()}bufferFormat(t,e,r,o){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.arrayBuffer),this.gl.vertexAttribPointer(this.attributeLocation,t,this.data_type,e,r,o),this.gl.enableVertexAttribArray(this.attributeLocation)}setData(t,e){let r;if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.arrayBuffer),r=t,"number"==typeof t[0]){r=new Array(t.length);for(let e=0;e<t.length;e++)r[e]=t[e]}else if(Array.isArray(t)){r=new Array(t.length*t[0].length);for(let e=0;e<t.length;e++)for(let o=0;o<t[0].length;o++)r[e*t[0].length+o]=t[e][o]}switch(this.data_type){case this.gl.FLOAT:this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(r),e);break;case this.gl.UNSIGNED_BYTE:this.gl.bufferData(this.gl.ARRAY_BUFFER,new Uint8Array(r),e)}}delete(){this.gl.deleteBuffer(this.arrayBuffer)}}class r{constructor(t,e,r,o){this.gl=t,this.data_type=o,this.data=null,this.uniformLocation=t.getUniformLocation(e,r)}setData(...t){switch(this.data_type){case"uniform1i":this.gl.uniform1i(this.uniformLocation,t[0]),this.data=t[0];break;case"uniform1f":this.gl.uniform1f(this.uniformLocation,t[0]),this.data=t[0];break;case"uniform2f":this.gl.uniform2f(this.uniformLocation,t[0],t[1]),this.data=[t[0],t[1]];break;case"uniform4f":this.gl.uniform4f(this.uniformLocation,t[0],t[1],t[2],t[3]),this.data=[t[0],t[1],t[2],t[3]];break;case"uniform2fv":this.gl.uniform2fv(this.uniformLocation,t[0]),this.data=t[0];break;case"uniform3fv":this.gl.uniform3fv(this.uniformLocation,t[0]),this.data=t[0];break;case"uniform4fv":this.gl.uniform4fv(this.uniformLocation,t[0]),this.data=t[0];break;case"uniformMatrix3fv":this.gl.uniformMatrix3fv(this.uniformLocation,!1,t[0]),this.data=t[0];break;case"uniformMatrix4fv":this.gl.uniformMatrix4fv(this.uniformLocation,!1,t[0]),this.data=t[0];break;default:throw new Error(`UniformClass: function ${this.type} has not been implemented.`)}}}try{const a=function(t,e="webgl2",r){const o=document.getElementById(t);if(!o)throw new Error(`HelperFunctions-createGLContext-Error: Could not locate canvas element with id ${t}`);return{gl:o.getContext(e,r),canvas:o}}("my_canvas"),i=a.gl;!function(t){const e=t.clientWidth,r=t.clientHeight,o=t.width!==e||t.height!==r;o&&(t.width=e,t.height=r)}(a.canvas),i.viewport(0,0,i.canvas.width,i.canvas.height);const s=t(i,i.VERTEX_SHADER,"#version 300 es\n\n// Receive position data from the buffer\nin vec2 a_position_v2;\n\n// Used to pass in the resolution of the canvas\nuniform vec2 u_resolution_v2;\n\nvoid main() {\n  // convert the position from pixels to 0.0 to 1.0\n  vec2 zeroToOne_v2 = a_position_v2 / u_resolution_v2;\n\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo_v2 = zeroToOne_v2 * 2.0;\n\n  // convert from 0->2 to -1 -> +1 (clip space)\n  vec2 clipSpace_v2 = zeroToTwo_v2 - 1.0;\n\n  // flip and assign position\n  gl_Position = vec4(clipSpace_v2 * vec2(1, -1), 0, 1);\n}"),h=function(t,e,r){const o=t.createProgram();if(t.attachShader(o,e),t.attachShader(o,r),t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS))return o;{const e=t.getProgramInfoLog(o);throw t.deleteProgram(o),new Error(`HelperFunctions-createProgram-Error: ${e}`)}}(i,s,t(i,i.FRAGMENT_SHADER,'#version 300 es\n\n// Fragment shaders don\'t have a default precision so we need\n//   to pick one. highp is a good default. It means "high precision"\n\nprecision highp float;\n\n// Color to be set by the program\nuniform vec4 u_color_v4;\n\n// We need to declare an output for the fragment shader\nout vec4 outColor_v4;\n\nvoid main() {\n  // outColor variable is responsible for setting (red, green, blue)\n  outColor_v4 = u_color_v4;\n}'));i.useProgram(h);const c=i.FLOAT,f=new e(i,c,h,"a_position_v2"),l=i.createVertexArray();i.bindVertexArray(l);{const t=2,e=!1,r=0,o=0;f.bufferFormat(t,c,e,r,o)}new r(i,h,"u_resolution_v2","uniform2f").setData(i.canvas.width,i.canvas.height);const u=new r(i,h,"u_color_v4","uniform4f");!function(t,e=[.9,.9,.9,1]){t.clearColor(e[0],e[1],e[2],e[3]),t.clearDepth(1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL)}(i);for(let t=0;t<50;++t){const t=n(o(300),o(300),o(300),o(300));f.setData(t,i.STATIC_DRAW),u.setData(Math.random(),Math.random(),Math.random(),1);const e=i.TRIANGLES,r=0,a=6;i.drawArrays(e,r,a)}}catch(t){console.log(t.message)}function o(t){return Math.floor(Math.random()*t)}function n(t,e,r,o){const n=t+r,a=e+o;return[t,e,n,e,t,a,t,a,n,e,n,a]}
//# sourceMappingURL=index.697a04de.js.map
